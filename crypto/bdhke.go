// Package crypto implements the cryptography used in the Cashu protocol
// as explained in [Cashu].
//
// [Cashu]: https://github.com/cashubtc/nuts/blob/main/00.md
package crypto

import (
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"math"
	"reflect"

	"github.com/decred/dcrd/dcrec/secp256k1/v4"
)

const DomainSeparator = "Secp256k1_HashToCurve_Cashu_"

//     Generates a secp256k1 point from a message.

//     The point is generated by hashing the message with a domain separator and then
//     iteratively trying to compute a point from the hash. An increasing uint32 counter
//     (byte order little endian) is appended to the hash until a point is found that lies on the curve.

//     The chance of finding a valid point is 50% for every iteration. The maximum number of iterations
//     is 2**16. If no valid point is found after 2**16 iterations, a ValueError is raised (this should
//     never happen in practice).

// The domain separator is b"Secp256k1_HashToCurve_Cashu_" or
// bytes.fromhex("536563703235366b315f48617368546f43757276655f43617368755f").
func HashToCurve(message []byte) (*secp256k1.PublicKey, error) {
	msgToHash := sha256.Sum256(append([]byte(DomainSeparator), message...))
	var counter uint32 = 0
	for counter < uint32(math.Exp2(16)) {
		// little endian counter
		c := make([]byte, 4)
		binary.LittleEndian.PutUint32(c, counter)

		hash := sha256.Sum256(append(msgToHash[:], c...))
		pkHash := append([]byte{0x02}, hash[:]...)
		point, err := secp256k1.ParsePubKey(pkHash)
		if err != nil {
			counter++
			continue
		}
		if point.IsOnCurve() {
			return point, nil
		}
	}
	return nil, errors.New("No valid point found")
}

// B_ = Y + rG
func BlindMessage(secret string, r *secp256k1.PrivateKey) (*secp256k1.PublicKey,
	*secp256k1.PrivateKey, error) {

	var ypoint, rpoint, blindedMessage secp256k1.JacobianPoint
	Y, err := HashToCurve([]byte(secret))
	if err != nil {
		return nil, nil, err
	}
	Y.AsJacobian(&ypoint)

	rpub := r.PubKey()
	rpub.AsJacobian(&rpoint)

	// blindedMessage = Y + rG
	secp256k1.AddNonConst(&ypoint, &rpoint, &blindedMessage)
	blindedMessage.ToAffine()
	B_ := secp256k1.NewPublicKey(&blindedMessage.X, &blindedMessage.Y)

	return B_, r, nil
}

// C_ = kB_
func SignBlindedMessage(B_ *secp256k1.PublicKey, k *secp256k1.PrivateKey) *secp256k1.PublicKey {
	var bpoint, result secp256k1.JacobianPoint
	B_.AsJacobian(&bpoint)

	// result = k * B_
	secp256k1.ScalarMultNonConst(&k.Key, &bpoint, &result)
	result.ToAffine()
	C_ := secp256k1.NewPublicKey(&result.X, &result.Y)

	return C_
}

// C = C_ - rK
func UnblindSignature(C_ *secp256k1.PublicKey, r *secp256k1.PrivateKey,
	K *secp256k1.PublicKey) *secp256k1.PublicKey {

	var Kpoint, rKPoint, CPoint secp256k1.JacobianPoint
	K.AsJacobian(&Kpoint)

	var rNeg secp256k1.ModNScalar
	rNeg.NegateVal(&r.Key)

	secp256k1.ScalarMultNonConst(&rNeg, &Kpoint, &rKPoint)

	var C_Point secp256k1.JacobianPoint
	C_.AsJacobian(&C_Point)
	secp256k1.AddNonConst(&C_Point, &rKPoint, &CPoint)
	CPoint.ToAffine()

	C := secp256k1.NewPublicKey(&CPoint.X, &CPoint.Y)
	return C
}

// k * HashToCurve(secret) == C
func Verify(secret string, k *secp256k1.PrivateKey, C *secp256k1.PublicKey) bool {
	Y, err := HashToCurve([]byte(secret))
	if err != nil {
		return false
	}
	return verify(Y, k, C)
}

func verify(Y *secp256k1.PublicKey, k *secp256k1.PrivateKey, C *secp256k1.PublicKey) bool {
	var Ypoint, result secp256k1.JacobianPoint
	Y.AsJacobian(&Ypoint)

	secp256k1.ScalarMultNonConst(&k.Key, &Ypoint, &result)
	result.ToAffine()
	pk := secp256k1.NewPublicKey(&result.X, &result.Y)

	return C.IsEqual(pk)
}

func HashE(publicKeys []*secp256k1.PublicKey) [32]byte {
	var keys string
	for _, pk := range publicKeys {
		keys += hex.EncodeToString(pk.SerializeUncompressed())
	}
	return sha256.Sum256([]byte(keys))
}

func GenerateDLEQ(
	a *secp256k1.PrivateKey,
	B_ *secp256k1.PublicKey,
	C_ *secp256k1.PublicKey,
) (*secp256k1.PrivateKey, *secp256k1.PrivateKey) {
	// random r
	var r *secp256k1.PrivateKey
	var err error
	for r == nil || err != nil {
		r, err = secp256k1.GeneratePrivateKey()
	}

	// r*B'
	var B_Point, R2Point secp256k1.JacobianPoint
	B_.AsJacobian(&B_Point)
	secp256k1.ScalarMultNonConst(&r.Key, &B_Point, &R2Point)
	R2Point.ToAffine()

	// R1 = r*G
	R1 := r.PubKey()
	// R2 = r*B'
	R2 := secp256k1.NewPublicKey(&R2Point.X, &R2Point.Y)

	// e = hash(R1,R2,A,C')
	ebytes := HashE([]*secp256k1.PublicKey{R1, R2, a.PubKey(), C_})
	e := secp256k1.PrivKeyFromBytes(ebytes[:])

	// s = r + e*a
	ea := e.Key.Mul(&a.Key)
	scalar := r.Key.Add(ea)
	s := secp256k1.NewPrivateKey(scalar)

	// can't return e here because value was modified in Mul
	// so getting private key e from hash
	return secp256k1.PrivKeyFromBytes(ebytes[:]), s
}

func VerifyDLEQ(
	e *secp256k1.PrivateKey,
	s *secp256k1.PrivateKey,
	A *secp256k1.PublicKey,
	B_ *secp256k1.PublicKey,
	C_ *secp256k1.PublicKey,
) bool {
	var R1Point, R2Point secp256k1.JacobianPoint

	// s*G
	var SPoint secp256k1.JacobianPoint
	s.PubKey().AsJacobian(&SPoint)

	// -e*A
	var eNeg secp256k1.ModNScalar
	eNeg.NegateVal(&e.Key)
	var APoint, eA_Point secp256k1.JacobianPoint
	A.AsJacobian(&APoint)
	secp256k1.ScalarMultNonConst(&eNeg, &APoint, &eA_Point)
	eA_Point.ToAffine()

	// R1 = s*G - e*A
	secp256k1.AddNonConst(&SPoint, &eA_Point, &R1Point)
	R1Point.ToAffine()

	// s*B'
	var B_Point, sB_Point secp256k1.JacobianPoint
	B_.AsJacobian(&B_Point)
	secp256k1.ScalarMultNonConst(&s.Key, &B_Point, &sB_Point)
	sB_Point.ToAffine()

	// -e*C'
	var C_Point, eC_Point secp256k1.JacobianPoint
	C_.AsJacobian(&C_Point)
	secp256k1.ScalarMultNonConst(&eNeg, &C_Point, &eC_Point)
	eC_Point.ToAffine()

	// R2 = s*B' - e*C'
	secp256k1.AddNonConst(&sB_Point, &eC_Point, &R2Point)
	R2Point.ToAffine()

	R1PublicKey := secp256k1.NewPublicKey(&R1Point.X, &R1Point.Y)
	R2PublicKey := secp256k1.NewPublicKey(&R2Point.X, &R2Point.Y)

	hash := HashE([]*secp256k1.PublicKey{R1PublicKey, R2PublicKey, A, C_})
	ebytes := e.Serialize()

	return reflect.DeepEqual(ebytes, hash[:])
}
